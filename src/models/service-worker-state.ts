import Protocol from 'devtools-protocol';
import {
  RequestMapping,
  ResponseMapping,
  MappedEvent,
  EventMapping,
  EventPredicate,
  MappedRequestMethod
} from 'chrome-debugging-client';
import { RaceCancellation } from 'race-cancellation';

export interface VersionStatusIdentifier {
  status: Protocol.ServiceWorker.ServiceWorkerVersionStatus;
  version?: string;
  runningStatus?: Protocol.ServiceWorker.ServiceWorkerVersionRunningStatus;
}

type SerializedStateIdentifier = string;

function identifierFromVersion(v: Protocol.ServiceWorker.ServiceWorkerVersion): VersionStatusIdentifier {
  return {
    version: v.versionId,
    status: v.status,
    runningStatus: v.runningStatus
  };
}

function serializeStateIdentifier({ version, status, runningStatus }:
  VersionStatusIdentifier): SerializedStateIdentifier {
  const sanitizedVersion = version ? version : '';
  const sanitizedRunningStatus = runningStatus ? runningStatus : '';
  const id = `${sanitizedVersion}:${status}:${sanitizedRunningStatus}`;
  return id;
}

function addTimeout<T>(promise: Promise<T>, msg: string, timeout: number = 6000): Promise<T> {
  const timedOut: Promise<T> = new Promise((_resolve, reject) => {
    setTimeout(() => {
      reject(new Error(msg));
    }, timeout);
  });
  return Promise.race([promise, timedOut]);
}

class StateIdMap<V> extends Map<any, V> {
  get(key: VersionStatusIdentifier) {
    return super.get(serializeStateIdentifier(key));
  }
  set(key: VersionStatusIdentifier, value: V) {
    return super.set(serializeStateIdentifier(key), value);
  }
}

class StateIdArrayMap<V> extends Map<any, V[]> {
  get(key: VersionStatusIdentifier) {
    const versionQuery = super.get(serializeStateIdentifier(key));
    const eventQuery = super.get(serializeStateIdentifier({
      status: key.status,
      runningStatus: key.runningStatus
    }));
    if (!versionQuery && !eventQuery) {
      return;
    }
    return (versionQuery || []).concat(eventQuery || []);
  }
  set(key: VersionStatusIdentifier, value: V[]) {
    return super.set(serializeStateIdentifier(key), value);
  }
}

/**
 * Interface for ServiceWorker class, generated by chrome-debugging-client, that represents
 * the raw API for the ServiceWorker DevTools protocl domain
 * @public
 */
/*
export interface IServiceWorker {
  skipWaiting: (params: Protocol.ServiceWorker.SkipWaitingRequest) => Promise<void>;

  workerErrorReported: Protocol.ServiceWorker.WorkerErrorReportedEvent | null;
  workerRegistrationUpdated: Protocol.ServiceWorker.WorkerRegistrationUpdatedEvent | null;
  workerVersionUpdated: Protocol.ServiceWorker.WorkerVersionUpdatedEvent | null;

  // Set all the other methods as optional until we actually start using them
  deliverPushMessage?: (params: Protocol.ServiceWorker.DeliverPushMessageRequest) => Promise<void>;
  disable?: () => Promise<void>;
  dispatchSyncEvent?: (params: Protocol.ServiceWorker.DispatchSyncEventRequest) => Promise<void>;
  enable?: () => Promise<void>;
  inspectWorker?: (params: Protocol.ServiceWorker.InspectWorkerRequest) => Promise<void>;
  setForceUpdateOnPageLoad?: (params: Protocol.ServiceWorker.SetForceUpdateOnPageLoadRequest) => Promise<void>;
  startWorker?: (params: Protocol.ServiceWorker.StartWorkerRequest) => Promise<void>;
  stopAllWorkers?: () => Promise<void>;
  stopWorker?: (params: Protocol.ServiceWorker.StopWorkerRequest) => Promise<void>;
  unregister?: (params: Protocol.ServiceWorker.UnregisterRequest) => Promise<void>;
  updateRegistration?: (params: Protocol.ServiceWorker.UpdateRegistrationRequest) => Promise<void>;
}
*/

type VersionListener = (v: Protocol.ServiceWorker.ServiceWorkerVersion) => void;

/*
class ServiceWorkerProtocolSession {
  private core: Promise<ServiceWorkerCore>;
  constructor(public targetId: string, clientP: Promise<IDebuggingProtocolClient>) {
    this.core = clientP.then(async (client) => {
      const networkDomain = new Network(client);
      await networkDomain.enable({});
      return {
        client,
        networkDomain
      };
    });
  }
  public async emulateOffline(offline: boolean) {
    await this.core;
    throw new Error('Offline emulation not working. See https://bugs.chromium.org/p/chromium/issues/detail?id=852127');
  }
}
*/

/**
 * ServiceWorkerState config options
 * @internal
 */
export interface IServiceWorkerStateOptions {
  log?: boolean;
}

export type ServiceWorkerErrorCallback = (err: Protocol.ServiceWorker.ServiceWorkerErrorMessage) => void;

export interface IPage {
  send<M extends MappedRequestMethod>(
    method: M,
    request: RequestMapping[M],
    raceCancellation?: RaceCancellation,
  ): Promise<ResponseMapping[M]>;
  on<E extends MappedEvent>(
    event: E,
    listener: (event: EventMapping[E]) => void,
  ): void;
  until<E extends MappedEvent>(
    event: E,
    predicate?: EventPredicate<EventMapping[E]>,
    raceCancellation?: RaceCancellation,
  ): Promise<EventMapping[E]>;
}

/**
 * Models the state of Service Workers for a particular client
 * @remarks
 * Effectively a wrapper around the {@link https://chromedevtools.github.io/devtools-protocol/tot/ServiceWorker
 * | ServiceWorker} domain of the Chrome DevTools Protocol.
 * @internal
 */
export class ServiceWorkerState {
  private versions: Map<number, Protocol.ServiceWorker.ServiceWorkerVersion>;
  private active: Protocol.ServiceWorker.ServiceWorkerVersion;
  private lastInstalled: Protocol.ServiceWorker.ServiceWorkerVersion;

  private log: boolean;
  private errors: Protocol.ServiceWorker.ServiceWorkerErrorMessage[];

  private stateListeners: StateIdArrayMap<VersionListener>;
  private stateHistory: StateIdMap<Protocol.ServiceWorker.ServiceWorkerVersion>;
  private page: IPage;

  // private targets: Map<string, ServiceWorkerProtocolSession>;

  private errorCallbacks: ServiceWorkerErrorCallback[];

  constructor(
    page: IPage,
    options: IServiceWorkerStateOptions = {}
  ) {
    this.versions = new Map();
    this.stateListeners = new StateIdArrayMap();
    this.stateHistory = new StateIdMap();
    this.log = !!options.log;

    // this.targets = new Map();
    this.errorCallbacks = [];

    this.errors = [];

    this.page = page;

    // TODO: Somehow add ability to listen to network requests from the service worker
    // The service worker might be its own client

    page.on('ServiceWorker.workerVersionUpdated', ({ versions }) => {
      for (let version of versions) {
        this.recordVersion(version);
      }
    });

    page.on('ServiceWorker.workerErrorReported', ({ errorMessage }) => {
      this.errors.push(errorMessage);
    });
  }
  public catchErrors(cb: ServiceWorkerErrorCallback) {
    this.errorCallbacks.push(cb);
  }
  public getErrors() {
    return this.errors;
  }
  public ensureNoErrors(handleError?: (err: Error) => void) {
    const errors = this.errors;
    this.errors = [];
    const cbs = this.errorCallbacks.length;
    if (errors.length) {
      // If we are handling the errors via registered callbacks, delegate
      if (cbs > 0) {
        for (let i = 0; i < errors.length; i++) {
          for (let x = 0; x < cbs; x++) {
            this.errorCallbacks[x](errors[i]);
          }
        }
      } else {
        // Otherwise throw and log

        // TODO: Better surface all the errors
        const err = new Error(`Uncaught error thrown in Service Worker: ${errors[0].errorMessage}`);
        if (handleError) {
          handleError(err);
        } else {
          throw err;
        }
      }
    }
  }
  private listen(id: VersionStatusIdentifier, listener: VersionListener) {
    let listeners = this.stateListeners.get(id) || [];
    listeners.push(listener);
    this.stateListeners.set(id, listeners);
  }
  private recordVersion(version: Protocol.ServiceWorker.ServiceWorkerVersion) {
    if (this.log) {
      console.log('[sw]', version.status, version.runningStatus, version.versionId);
    }
    this.versions.set(Number(version.versionId), version);
    const id = identifierFromVersion(version);
    this.stateHistory.set(id, version);

    /*
    if (version.targetId && !this.targets.has(version.targetId)) {
      const attach = this.session.attachToTarget(this.browserClient, version.targetId);
      this.targets.set(version.targetId, new ServiceWorkerProtocolSession(version.targetId, attach));
    }
    */
    if (version.status === 'activated' && version.runningStatus === 'running') {
      this.handleActivated(version);
    } else if (version.status === 'installed' && version.runningStatus === 'running') {
      this.handleInstalled(version);
    }

    const listeners = this.stateListeners.get(id);
    if (listeners) {
      listeners.forEach((listener) => {
        listener(version);
      });
    }
  }

  public debug() {
    this.log = true;
  }

  public waitForInstalled(version?: string) {
    if (!version && this.lastInstalled) {
      return Promise.resolve(this.lastInstalled);
    }
    return this.waitForState({
      status: 'installed',
      version
    });
  }

  public waitForActivated(version?: string) {
    if (!version && this.active) {
      return Promise.resolve(this.active);
    }
    return this.waitForState({
      status: 'activated',
      version
    });
  }

  public waitForActivation() {
    return this.waitForState('activated');
  }

  public waitForInstallation() {
    return this.waitForState('installed');
  }

  public waitForNextInstalled(version: Protocol.ServiceWorker.ServiceWorkerVersion) {
    return this.page.until('ServiceWorker.workerVersionUpdated', ({ versions }) => {
      for (let i = 0; i < versions.length; i++) {
        const { versionId, status, runningStatus } = versions[i];
        if (status === 'installed' && runningStatus === 'running' && versionId > version.versionId) {
          return true;
        }
      }
      return false;
    });
  }

  public waitForVersionUpdate(predicate: (v: Protocol.ServiceWorker.ServiceWorkerVersion) => boolean,
    label: string, timeout: number = 1000): Promise<Protocol.ServiceWorker.WorkerVersionUpdatedEvent> {
    return Promise.race([
      this.page.until('ServiceWorker.workerVersionUpdated', ({ versions }) => {
        for (let i = 0; i < versions.length; i++) {
          if (predicate(versions[i])) {
            return true;
          }
        }
        return false;
      }),
      new Promise((_r, reject) => {
        setTimeout(() => {
          reject(`Timeout waiting for service worker version update: ${label}`);
        }, timeout);
      })
    ]) as Promise<Protocol.ServiceWorker.WorkerVersionUpdatedEvent>;
  }

  // Potentially tricky behavior: If you specify a version in addition to a state, will resolve if event
  // happened in the past. If you only provide a state, will NOT resolve if event happened in past
  // TODO: Add tests for above ^^
  // TODO: Need a more robust event listening engine now that we have 3 different properties on VersionStatusIdentifier
  public waitForState(arg: VersionStatusIdentifier | Protocol.ServiceWorker.ServiceWorkerVersionStatus):
    Promise<Protocol.ServiceWorker.ServiceWorkerVersion> {
    const id: VersionStatusIdentifier = typeof arg === 'string' ? { status: arg } : arg;
    if (!id.runningStatus) {
      id.runningStatus = 'running';
    }
    const existingHistory = this.stateHistory.get(id);
    if (existingHistory) {
      return Promise.resolve(existingHistory);
    }
    return addTimeout(new Promise((resolve) => {
      this.listen(id, (result) => {
        // Wait until the next tick so that any state changes take effect first
        // tslint:disable-next-line:no-floating-promises
        Promise.resolve().then(() => {
          resolve(result);
        });
      });
    }), `Waiting for service worker version ${id.version} to be ${id.status} timed out`, 10000);
  }

  private handleActivated(version: Protocol.ServiceWorker.ServiceWorkerVersion) {
    this.active = version;
  }

  private handleInstalled(version: Protocol.ServiceWorker.ServiceWorkerVersion) {
    this.lastInstalled = version;
  }

  public getActive() {
    if (!this.active) {
      throw new Error('Error calling getActive(): There is no active worker yet. Try using waitForActivated()');
    }
    return this.active;
  }

  public getLastInstalled() {
    return this.lastInstalled;
  }

  public skipWaiting() {
    return this.page.send('ServiceWorker.skipWaiting', {
      scopeURL: '/'
    });
  }

  public emulateOffline(offline: boolean) {
    throw new Error('Offline emulation not working. See https://bugs.chromium.org/p/chromium/issues/detail?id=852127');
    /*
    return Promise.all(Array.from(this.targets).map(([key, sw]) => {
      return sw.emulateOffline(offline);
    }));
    */
  }

  public close() {
    // TODO: Once we move to using new BrowserContext per test, instead of an entire new ISession,
    // we need to manually close all the ServiceWorkerProtocolSessions
    this.versions.clear();
    this.stateListeners.clear();
    this.stateHistory.clear();
    // this.targets.clear();
    this.errorCallbacks = [];
  }
}