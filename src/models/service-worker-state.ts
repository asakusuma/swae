import {
  ServiceWorker
} from 'chrome-debugging-client/dist/protocol/tot';

interface StateIdentifier {
  version?: string;
  state: ServiceWorker.ServiceWorkerVersionStatus;
}

type SerializedStateIdentifier = string;

function identifierFromVersion(v: ServiceWorker.ServiceWorkerVersion): StateIdentifier {
  return {
    version: v.versionId,
    state: v.status
  };
}

function serializeStateIdentifier({ version, state }: StateIdentifier): SerializedStateIdentifier {
  const sanitizedVersion = version ? version : '';
  const id = `${sanitizedVersion}:${state}`;
  return id;
}

function addTimeout<T>(promise: Promise<T>, msg: string, timeout: number = 6000): Promise<T> {
  const timedOut: Promise<T> = new Promise((_resolve, reject) => {
    setTimeout(() => {
      reject(new Error(msg));
    }, timeout);
  });
  return Promise.race([promise, timedOut]);
}

class StateIdMap<V> extends Map<any, V> {
  get(key: StateIdentifier) {
    return super.get(serializeStateIdentifier(key));
  }
  set(key: StateIdentifier, value: V) {
    return super.set(serializeStateIdentifier(key), value);
  }
}

class StateIdArrayMap<V> extends Map<any, V[]> {
  get(key: StateIdentifier) {
    const versionQuery = super.get(serializeStateIdentifier(key));
    const eventQuery = super.get(serializeStateIdentifier({
      state: key.state
    }));
    if (!versionQuery && !eventQuery) {
      return;
    }
    return (versionQuery || []).concat(eventQuery || []);
  }
  set(key: StateIdentifier, value: V[]) {
    return super.set(serializeStateIdentifier(key), value);
  }
}

/**
 * Interface for ServiceWorker class, generated by chrome-debugging-client, that represents
 * the raw API for the ServiceWorker DevTools protocl domain
 * @public
 */
export interface IServiceWorker {
  skipWaiting: (params: ServiceWorker.SkipWaitingParameters) => Promise<void>;

  workerErrorReported: ServiceWorker.WorkerErrorReportedHandler | null;
  workerRegistrationUpdated: ServiceWorker.WorkerRegistrationUpdatedHandler | null;
  workerVersionUpdated: ServiceWorker.WorkerVersionUpdatedHandler | null;

  // Set all the other methods as optional until we actually start using them
  deliverPushMessage?: (params: ServiceWorker.DeliverPushMessageParameters) => Promise<void>;
  disable?: () => Promise<void>;
  dispatchSyncEvent?: (params: ServiceWorker.DispatchSyncEventParameters) => Promise<void>;
  enable?: () => Promise<void>;
  inspectWorker?: (params: ServiceWorker.InspectWorkerParameters) => Promise<void>;
  setForceUpdateOnPageLoad?: (params: ServiceWorker.SetForceUpdateOnPageLoadParameters) => Promise<void>;
  startWorker?: (params: ServiceWorker.StartWorkerParameters) => Promise<void>;
  stopAllWorkers?: () => Promise<void>;
  stopWorker?: (params: ServiceWorker.StopWorkerParameters) => Promise<void>;
  unregister?: (params: ServiceWorker.UnregisterParameters) => Promise<void>;
  updateRegistration?: (params: ServiceWorker.UpdateRegistrationParameters) => Promise<void>;
}

type VersionListener = (v: ServiceWorker.ServiceWorkerVersion) => void;

/**
 * ServiceWorkerState config options
 * @internal
 */
export interface IServiceWorkerStateOptions {
  log?: boolean;
}

export type ServiceWorkerErrorCallback = (err: ServiceWorker.ServiceWorkerErrorMessage) => void;

/**
 * Models the state of Service Workers for a particular client
 * @remarks
 * Effectively a wrapper around the {@link https://chromedevtools.github.io/devtools-protocol/tot/ServiceWorker
 * | ServiceWorker} domain of the Chrome DevTools Protocol.
 * @internal
 */
export class ServiceWorkerState {
  private versions: Map<number, ServiceWorker.ServiceWorkerVersion>;
  private active: ServiceWorker.ServiceWorkerVersion;
  private lastInstalled: ServiceWorker.ServiceWorkerVersion;

  private serviceWorker: IServiceWorker;

  private log: boolean;
  private errors: ServiceWorker.ServiceWorkerErrorMessage[];

  private stateListeners: StateIdArrayMap<VersionListener>;
  private stateHistory: StateIdMap<ServiceWorker.ServiceWorkerVersion>;

  private errorCallbacks: ServiceWorkerErrorCallback[];

  constructor(serviceWorker: IServiceWorker, options: IServiceWorkerStateOptions = {}) {
    this.versions = new Map();
    this.stateListeners = new StateIdArrayMap();
    this.stateHistory = new StateIdMap();
    this.log = !!options.log;

    this.errorCallbacks = [];

    this.errors = [];

    serviceWorker.workerVersionUpdated = ({ versions }) => {
      for (let version of versions) {
        this.recordVersion(version);
      }
    };

    serviceWorker.workerErrorReported = ({ errorMessage }) => {
      this.errors.push(errorMessage);
    };

    this.serviceWorker = serviceWorker;
  }
  public catchErrors(cb: ServiceWorkerErrorCallback) {
    this.errorCallbacks.push(cb);
  }
  public getErrors() {
    return this.errors;
  }
  public ensureNoErrors() {
    const errors = this.errors;
    this.errors = [];
    const cbs = this.errorCallbacks.length;
    if (errors.length) {
      // If we are handling the errors via registered callbacks, delegate
      if (cbs > 0) {
        for (let i = 0; i < errors.length; i++) {
          for (let x = 0; x < cbs; x++) {
            this.errorCallbacks[x](errors[i]);
          }
        }
      } else {
        // Otherwise throw and log

        // TODO: Better surface all the errors
        throw new Error(`Uncaught error thrown in Service Worker: ${errors[0].errorMessage}`);
      }
    }
  }
  private listen(id: StateIdentifier, listener: VersionListener) {
    let listeners = this.stateListeners.get(id);
    if (!listeners) {
      listeners = [];
      this.stateListeners.set(id, listeners);
    }
    listeners.push(listener);
  }
  private recordVersion(version: ServiceWorker.ServiceWorkerVersion) {
    if (this.log) {
      console.log('[sw]', version.status, version.runningStatus, version.versionId);
    }
    this.versions.set(Number(version.versionId), version);
    const id = identifierFromVersion(version);
    this.stateHistory.set(id, version);

    if (version.status === 'activated' && version.runningStatus === 'running') {
      this.handleActivated(version);
    } else if (version.status === 'installed' && version.runningStatus === 'running') {
      this.handleInstalled(version);
    }

    const listeners = this.stateListeners.get(id);
    if (listeners) {
      listeners.forEach((listener) => {
        listener(version);
      });
    }
  }

  public debug() {
    this.log = true;
  }

  public waitForInstalled(version?: string) {
    if (!version && this.lastInstalled) {
      return Promise.resolve(this.lastInstalled);
    }
    return this.waitForState('installed', version);
  }

  public waitForActivated(version?: string) {
    if (!version && this.active) {
      return Promise.resolve(this.active);
    }
    return this.waitForState('activated', version);
  }

  public waitForActivation() {
    return this.waitForState('activated');
  }

  public waitForInstallation() {
    return this.waitForState('installed');
  }

  // Potentially tricky behavior: If you specify a version in addition to a state, will resolve if event
  // happened in the past. If you only provide a state, will NOT resolve if event happened in past
  // TODO: Add tests for above ^^
  private waitForState(
    state: ServiceWorker.ServiceWorkerVersionStatus,
    version?: string
  ): Promise<ServiceWorker.ServiceWorkerVersion> {
    const existingHistory = this.stateHistory.get({ version, state });
    if (existingHistory) {
      return Promise.resolve(existingHistory);
    }
    return addTimeout(new Promise((resolve) => {
      this.listen({
        version,
        state
      }, (result) => {
        // Wait until the next tick so that any state changes take effect first
        Promise.resolve().then(() => {
          resolve(result);
        });
      });
    }), `Waiting for service worker version ${version} to be ${state} timed out`, 10000);
  }

  private handleActivated(version: ServiceWorker.ServiceWorkerVersion) {
    this.active = version;
  }

  private handleInstalled(version: ServiceWorker.ServiceWorkerVersion) {
    this.lastInstalled = version;
  }

  public getActive() {
    if (!this.active) {
      throw new Error('Error calling getActive(): There is no active worker yet. Try using waitForActivated()');
    }
    return this.active;
  }

  public getLastInstalled() {
    return this.lastInstalled;
  }

  public skipWaiting() {
    return this.serviceWorker.skipWaiting({
      scopeURL: '/'
    });
  }
}